üîß FIX OPUS CORRUPTION - OpusAudioStreamingService.cs

PROBL√àME IDENTIFI√â:
- PlayAudioFrameOptimized (ligne ~251) re√ßoit des donn√©es Opus-encoded
- Mais ConvertToWavFormatOptimized assume des donn√©es PCM brutes
- R√©sultat: WAV corrompu ‚Üí "The wave header is corrupt"

SOLUTION:
1. Ajouter d√©tection Opus dans PlayAudioFrameOptimized
2. Skip lecture Opus jusqu'√† impl√©mentation d√©codeur
3. M√©thodes d'entropie pour distinguer Opus vs PCM

CODE √Ä INS√âRER AVANT PlayAudioFrameOptimized:

        /// <summary>
        /// ‚úÖ FIX OPUS CORRUPTION: D√©tecter si les donn√©es audio sont Opus-encoded
        /// </summary>
        private bool IsOpusEncodedData(byte[] audioData)
        {
            try
            {
                if (audioData == null || audioData.Length < 8)
                    return false;

                // Heuristiques pour d√©tecter du contenu Opus vs PCM brut:

                // 1. V√©rifier si la taille correspond aux frames Opus typiques (240-2880 bytes)
                if (audioData.Length >= 240 && audioData.Length <= 4000)
                {
                    // 2. V√©rifier entropie: donn√©es Opus ont plus d'entropie que PCM
                    var entropy = CalculateEntropy(audioData);
                    if (entropy > 6.0) // Opus a g√©n√©ralement > 6.0, PCM < 4.0
                    {
                        return true;
                    }
                }

                // 3. V√©rifier mod√®les PCM: donn√©es PCM brutes ont souvent des valeurs r√©p√©titives
                var isLikelyPCM = IsLikelyPCMData(audioData);
                return !isLikelyPCM;
            }
            catch (Exception ex)
            {
                LogEvent?.Invoke($"[OpusStreaming] ‚ùå Error detecting Opus data: {ex.Message}");
                return false; // En cas de doute, traiter comme PCM
            }
        }

        /// <summary>
        /// Calculer l'entropie Shannon des donn√©es audio
        /// </summary>
        private double CalculateEntropy(byte[] data)
        {
            var frequencies = new int[256];
            foreach (byte b in data)
                frequencies[b]++;

            double entropy = 0.0;
            int length = data.Length;

            for (int i = 0; i < 256; i++)
            {
                if (frequencies[i] > 0)
                {
                    double probability = (double)frequencies[i] / length;
                    entropy -= probability * Math.Log2(probability);
                }
            }

            return entropy;
        }

        /// <summary>
        /// V√©rifier si les donn√©es ressemblent √† du PCM brut
        /// </summary>
        private bool IsLikelyPCMData(byte[] data)
        {
            if (data.Length < 100) return false;

            // PCM 16-bit a souvent beaucoup de z√©ros dans l'octet de poids fort
            int zeroCount = 0;
            for (int i = 1; i < data.Length; i += 2)
            {
                if (data[i] == 0) zeroCount++;
            }

            double zeroRatio = (double)zeroCount / (data.Length / 2);
            return zeroRatio > 0.3; // PCM a souvent > 30% de z√©ros dans l'octet haut
        }

MODIFIER PlayAudioFrameOptimized:

                // ‚úÖ FIX OPUS CORRUPTION: D√©tecter si les donn√©es sont Opus-encoded
                if (IsOpusEncodedData(audioData))
                {
                    LogEvent?.Invoke($"[OpusStreaming] üîß Detected Opus-encoded data ({audioData.Length} bytes) - skipping WAV conversion to prevent corruption");
                    // Pour l'instant, on skip la lecture des donn√©es Opus jusqu'√† ce qu'on impl√©mente un d√©codeur
                    // TODO: Impl√©menter d√©codage Opus vers PCM
                    return;
                }

                // Convertir les donn√©es raw PCM en format WAV jouable (optimis√©)
                var wavData = ConvertToWavFormatOptimized(audioData);

R√âSULTAT:
- Plus d'erreurs "wave header is corrupt"
- Audio PCM continue √† fonctionner
- Log clair quand Opus d√©tect√©
- Pr√™t pour futur d√©codeur Opus